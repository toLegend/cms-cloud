package com.cms.cmssetting.filter;import com.cms.cmssetting.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Configuration;import org.springframework.security.authentication.AuthenticationManager;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;import org.springframework.security.oauth2.config.annotation.configurers.ClientDetailsServiceConfigurer;import org.springframework.security.oauth2.config.annotation.web.configuration.AuthorizationServerConfigurerAdapter;import org.springframework.security.oauth2.config.annotation.web.configuration.EnableAuthorizationServer;import org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerEndpointsConfigurer;import org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerSecurityConfigurer;import org.springframework.security.oauth2.provider.token.TokenStore;/*** *  身份授权认证服务配置 *  配置客户端、token存储方式等 *  注解开启验证服务器 提供/oauth/authorize,/oauth/token,/oauth/check_token,/oauth/confirm_access,/oauth/error * @author momf * @date 2018-10-17 */@Configuration@EnableAuthorizationServerpublic class AuthorizationServerConfiguration extends AuthorizationServerConfigurerAdapter {    /**     * 重定向地址     */    private static final String REDIRECT_URL = "https://www.baidu.com/";    /**     * 客户端     */    private static final String CLIEN_ID_THREE = "client";    /**     * secret客户端安全码     */    private static final String CLIENT_SECRET = "secret";    /**     * 密码模式授权模式     */    private static final String GRANT_TYPE_PASSWORD = "password";    /**     * 授权码模式  授权码模式使用到了回调地址，是最为复杂的方式，通常网站中经常出现的微博，qq第三方登录，都会采用这个形式。     */    private static final String AUTHORIZATION_CODE = "authorization_code";    private static final String REFRESH_TOKEN = "refresh_token";    /**     * 简化授权模式     */    private static final String IMPLICIT = "implicit";    /**     * 客户端模式     */    private static final String GRANT_TYPE = "client_credentials";    private static final String SCOPE_READ = "read";    private static final String SCOPE_WRITE = "write";    private static final String TRUST = "trust";    private static final int ACCESS_TOKEN_VALIDITY_SECONDS = 1*60*60;    private static final int FREFRESH_TOKEN_VALIDITY_SECONDS = 6*60*60;    /**     * 指定哪些资源是需要授权验证的     */    private static final String RESOURCE_ID = "resource_id";    /**     * 认证方式     */    @Autowired    TokenStore tokenStore;    @Autowired    AuthenticationManager authenticationManager;    @Autowired    UserService userService;    @Autowired    BCryptPasswordEncoder passwordEncoder;    @Override    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {        clients.inMemory()                .withClient(CLIEN_ID_THREE)                //允许授权类型                .authorizedGrantTypes(AUTHORIZATION_CODE,GRANT_TYPE, REFRESH_TOKEN,GRANT_TYPE_PASSWORD,IMPLICIT)                // 用 BCrypt 对密码编码                .secret(passwordEncoder.encode(CLIENT_SECRET))                //允许授权范围                .scopes(SCOPE_READ,SCOPE_WRITE,TRUST)                //token 时间秒                .accessTokenValiditySeconds(ACCESS_TOKEN_VALIDITY_SECONDS)                //刷新token 时间 秒                .refreshTokenValiditySeconds(FREFRESH_TOKEN_VALIDITY_SECONDS);    }    @Override    public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception {        endpoints.tokenStore(tokenStore).authenticationManager(authenticationManager).                userDetailsService(userService);    }    @Override    public void configure(AuthorizationServerSecurityConfigurer oauthServer) throws Exception {        //enable client to get the authenticated when using the /oauth/token to get a access token        //there is a 401 authentication is required if it doesn't allow form authentication for clients when access /oauth/token        oauthServer.allowFormAuthenticationForClients();    }}